<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Particle Physics Animation</title>
    <style>
        /* Basic styles for the body and canvas */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            background-color: #000;
        }

        /* UI Buttons in the top right */
        .ui-container {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 10px;
            visibility: hidden; /* Hidden until warning is accepted */
        }
        .icon-button {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 40, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            transition: background-color 0.2s;
        }
        .icon-button:hover {
            background: rgba(60, 60, 60, 0.8);
        }
        .icon-button svg {
            width: 28px;
            height: 28px;
            stroke: #fff;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }
        #play-icon {
             fill: #fff;
             stroke: none;
        }

        /* Modal backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1002;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }
        .modal-backdrop.visible {
            display: flex;
        }

        /* Styles for the controls modal */
        .controls-modal {
            background: rgba(30, 30, 30, 0.85);
            padding: 2vw 4vw;
            border-radius: 15px;
            color: #eee;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        .controls-modal h2 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.5em;
            text-align: center;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .control-group input[type="range"],
        .control-group select {
            width: 100%;
            cursor: pointer;
            box-sizing: border-box;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            font-size: 1em;
        }
        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            vertical-align: middle;
            margin-right: 10px;
            cursor: pointer;
        }
        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 2em;
            cursor: pointer;
            line-height: 1;
        }
        #particle-count-display {
            font-weight: bold;
            color: #8cff78;
        }
        
        /* Warning Modal Styles */
        #warning-modal {
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000; /* Highest z-index for the initial warning */
        }
        .warning-content {
            background: #1e1e1e;
            color: #ddd;
            padding: 30px;
            border-radius: 10px;
            width: 90vw;
            max-width: 500px;
            text-align: left;
            border: 1px solid #444;
        }
        .warning-content h2 {
            color: #ffcc00;
            margin-top: 0;
        }
        .warning-content p {
            line-height: 1.6;
        }
        .warning-content input {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            margin-top: 10px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 5px;
        }
        .warning-content button {
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            background: #2a75d2;
            border: none;
            color: #fff;
            font-size: 1.1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .warning-content button:hover {
            background: #3a85e2;
        }
    </style>
</head>
<body>
    <canvas id="animationCanvas"></canvas>

    <div class="ui-container" id="ui-container">
        <div class="icon-button" id="open-menu-button" title="Open Controls">
            <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
        </div>
        <div class="icon-button" id="reset-button" title="Reset Animation">
            <svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </div>
        <div class="icon-button" id="play-pause-button" title="Pause Animation">
            <svg id="pause-icon" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
            <svg id="play-icon" viewBox="0 0 24 24" style="display: none;"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        </div>
    </div>
    
    <div class="modal-backdrop" id="modal-backdrop">
        <div class="controls-modal">
            <button class="close-button" id="close-menu-button">&times;</button>
            <h2>Controls</h2>
            <div class="control-group"><input type="checkbox" id="collisions-checkbox"><label for="collisions-checkbox" style="display: inline-block;">Particle Collisions</label></div>
            <div class="control-group"><label for="color-palette-select">Color Palette</label><select id="color-palette-select"></select></div>
            <div class="control-group"><label for="shape-select">Boundary Shape</label><select id="shape-select"></select></div>
            <div class="control-group"><input type="checkbox" id="boundary-checkbox" checked><label for="boundary-checkbox" style="display: inline-block;">Enable Boundary</label></div>
            <div class="control-group"><label for="max-particles-input">Max Particles (<span id="max-particles-value">2000</span>)</label><input type="range" id="max-particles-input" min="100" max="10000" step="100" value="2000"></div>
            <div class="control-group"><label for="bounciness-slider">Bounciness (<span id="bounciness-value">80</span>%)</label><input type="range" id="bounciness-slider" min="0" max="100" value="80"></div>
            <div class="control-group"><label for="particle-size-slider">Particle Size (<span id="particle-size-value">10</span>)</label><input type="range" id="particle-size-slider" min="2" max="30" value="10"></div>
            <div class="control-group"><label for="speed-slider">Speed (<span id="speed-value">3</span>)</label><input type="range" id="speed-slider" min="1" max="15" value="3"></div>
            <div class="control-group"><label for="spawn-rate-slider">Spawn Rate (<span id="spawn-rate-value">2</span>)</label><input type="range" id="spawn-rate-slider" min="1" max="20" value="2"></div>
            <div class="control-group"><label for="connect-dist-slider">Connect Distance (<span id="connect-dist-value">0</span>)</label><input type="range" id="connect-dist-slider" min="0" max="200" value="0"></div>
            <div class="control-group"><label for="gravity-slider">Mouse Gravity (<span id="gravity-value">0</span>)</label><input type="range" id="gravity-slider" min="-100" max="100" value="0"></div>
            <div class="control-group"><label for="trail-slider">Trail Length (<span id="trail-value">85</span>%)</label><input type="range" id="trail-slider" min="0" max="99" value="85"></div>
            <div class="control-group"><p>Live Particles: <span id="particle-count-display">0</span></p></div>
        </div>
    </div>

    <!-- Warning Modal -->
    <div class="modal-backdrop visible" id="warning-modal">
        <div class="warning-content">
            <h2>Photosensitivity Warning</h2>
            <p>This application generates flashing lights and high-contrast patterns that may trigger seizures in individuals with photosensitive epilepsy. It can also cause eye strain, headaches, or dizziness.</p>
            <p>To reduce risks, use the controls to lower particle count and speed, and increase trail length. Use in a well-lit room and take frequent breaks.</p>
            <p>Type <strong>I agree</strong> to continue.</p>
            <input type="text" id="warning-input" placeholder="Type here...">
            <button id="warning-agree-button">Continue</button>
        </div>
    </div>


    <script>
        // --- 1. SETUP ---
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. CONFIGURATION & STATE ---
        const config = {
            maxParticles: 2000, particleSize: 10, particleSpeed: 3,
            bounciness: 0.8, enableCollisions: false, mouseGravity: 0, trailAmount: 0.15,
            spawnRate: 2, boundaryEnabled: true, connectDistance: 0, activePalette: []
        };

        let particles = [];
        let center = { x: canvas.width / 2, y: canvas.height / 2 };
        let mouse = { x: center.x, y: center.y };
        let boundaryPoints = [];
        let isPaused = true; // Start paused until warning is accepted
        let animationFrameId;

        // --- 3. DEFINITIONS (SHAPES, PALETTES) ---
        const PALETTES = {
            'Neon': ['#ff00ff', '#00ffff', '#ffff00', '#ff0099', '#00ff00'],
            'Sunset': ['#ff4848', '#ff8c42', '#ffc857', '#8a5a8c', '#5a3d5c'],
            'Ocean': ['#00a6fb', '#0582ca', '#006494', '#003554', '#051923'],
            'Forest': ['#8fb339', '#4a7856', '#2d4d33', '#1e3522', '#0a1a0a'],
            'Pastel': ['#f7d6e0', '#f2b5d4', '#e491c8', '#a67db8', '#735d78'],
            'Monochrome': ['#ffffff', '#cccccc', '#999999', '#666666', '#333333'],
        };
        config.activePalette = PALETTES['Neon'];

        const SHAPES = {
            'Open Field': [],
            'Circle': (s=80) => Array.from({length:s},(_,i)=>({x:Math.cos(i/s*Math.PI*2),y:Math.sin(i/s*Math.PI*2)})),
            'Square': [{x:-1,y:-1}, {x:1,y:-1}, {x:1,y:1}, {x:-1,y:1}],
            'Triangle': [{x:0,y:-1}, {x:1,y:0.8}, {x:-1,y:0.8}],
            'Hexagon': (s=6) => SHAPES.Circle(s),
            'Star': () => Array.from({length:10},(_,i)=>({x:Math.cos((i/10)*Math.PI*2-Math.PI/2)*((i%2===0)?1:0.4),y:Math.sin((i/10)*Math.PI*2-Math.PI/2)*((i%2===0)?1:0.4)})),
            'Heart': () => Array.from({length:100},(_,i)=>{const t=(i/100)*Math.PI*2;return{x:0.8*16*Math.sin(t)**3/13,y:-0.8*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))/13}}),
            'Gear': () => Array.from({length:24},(_,i)=>({x:Math.cos(Math.floor(i/2)/12*Math.PI*2)*((i%4<2)?1:0.7),y:Math.sin(Math.floor(i/2)/12*Math.PI*2)*((i%4<2)?1:0.7)})),
            'Frame': [{x:-1,y:-1},{x:1,y:-1},{x:1,y:1},{x:-1,y:1},{x:-1,y:-1},{x:-0.8,y:-0.8},{x:-0.8,y:0.8},{x:0.8,y:0.8},{x:0.8,y:-0.8},{x:-0.8,y:-0.8}],
            'Diamond': [{x:0,y:-1}, {x:1,y:0}, {x:0,y:1}, {x:-1,y:0}],
        };

        // --- 4. PHYSICS & HELPER CLASSES ---
        class Point { constructor(x, y, data) { this.x = x; this.y = y; this.data = data; } }
        class Rectangle {
            constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
            contains(point) { return (point.x >= this.x && point.x <= this.x + this.w && point.y >= this.y && point.y <= this.y + this.h); }
            intersects(range) { return !(range.x > this.x + this.w || range.x + range.w < this.x || range.y > this.y + this.h || range.y + range.h < this.y); }
        }
        class QuadTree {
            constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
            subdivide() {
                const { x, y, w, h } = this.boundary;
                this.ne = new QuadTree(new Rectangle(x + w / 2, y, w / 2, h / 2), this.capacity);
                this.nw = new QuadTree(new Rectangle(x, y, w / 2, h / 2), this.capacity);
                this.se = new QuadTree(new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2), this.capacity);
                this.sw = new QuadTree(new Rectangle(x, y + h / 2, w / 2, h / 2), this.capacity);
                this.divided = true;
            }
            insert(point) {
                if (!this.boundary.contains(point)) return false;
                if (this.points.length < this.capacity) { this.points.push(point); return true; }
                if (!this.divided) this.subdivide();
                return (this.ne.insert(point) || this.nw.insert(point) || this.se.insert(point) || this.sw.insert(point));
            }
            query(range, found = []) {
                if (!this.boundary.intersects(range)) return found;
                for (let p of this.points) if (range.contains(p)) found.push(p.data);
                if (this.divided) { this.nw.query(range, found); this.ne.query(range, found); this.sw.query(range, found); this.se.query(range, found); }
                return found;
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.radius = config.particleSize / 2 + Math.random() * (config.particleSize / 2);
                const angle = Math.random() * Math.PI * 2;
                const speed = (config.particleSpeed / 2) + Math.random() * (config.particleSpeed);
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                this.mass = this.radius * 0.5;
                this.color = config.activePalette[Math.floor(Math.random() * config.activePalette.length)];
            }
            update() {
                if (config.mouseGravity !== 0) {
                    const dx = this.x - mouse.x; const dy = this.y - mouse.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > 100) {
                        const force = config.mouseGravity / distSq;
                        this.vx -= dx * force; this.vy -= dy * force;
                    }
                }
                this.x += this.vx; this.y += this.vy;
            }
            draw() {
                ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- 5. ANIMATION & DRAWING LOGIC ---
        function generateBoundaryPoints(shapeKey) {
            const shapeGenerator = SHAPES[shapeKey];
            const normalizedPoints = typeof shapeGenerator === 'function' ? shapeGenerator() : shapeGenerator;
            if (!normalizedPoints || normalizedPoints.length === 0) { boundaryPoints = []; return; }
            const scale = Math.min(canvas.width, canvas.height) * 0.45;
            boundaryPoints = normalizedPoints.map(p => ({ x: p.x * scale + center.x, y: p.y * scale + center.y }));
        }

        function handleParticleCollisions() {
            let qtree = new QuadTree(new Rectangle(0, 0, canvas.width, canvas.height), 4);
            for (let p of particles) qtree.insert(new Point(p.x, p.y, p));
            for (let p of particles) {
                let range = new Rectangle(p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2);
                let others = qtree.query(range);
                for (let other of others) {
                    if (p === other) continue;
                    const dx = other.x - p.x, dy = other.y - p.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < p.radius + other.radius) resolveCollision(p, other);
                }
            }
        }
        
        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x, dy = p2.y - p1.y, dist = Math.hypot(dx, dy) || 1;
            const normalX = dx / dist, normalY = dy / dist;
            const tangentX = -normalY, tangentY = normalX;
            const dotTan1 = p1.vx * tangentX + p1.vy * tangentY;
            const dotTan2 = p2.vx * tangentX + p2.vy * tangentY;
            const dotNorm1 = p1.vx * normalX + p1.vy * normalY;
            const dotNorm2 = p2.vx * normalX + p2.vy * normalY;
            const m1 = (dotNorm1 * (p1.mass - p2.mass) + 2 * p2.mass * dotNorm2) / (p1.mass + p2.mass);
            const m2 = (dotNorm2 * (p2.mass - p1.mass) + 2 * p1.mass * dotNorm1) / (p1.mass + p2.mass);
            p1.vx = tangentX * dotTan1 + normalX * m1;
            p1.vy = tangentY * dotTan1 + normalY * m1;
            p2.vx = tangentX * dotTan2 + normalX * m2;
            p2.vy = tangentY * dotTan2 + normalY * m2;
            const overlap = 0.5 * (p1.radius + p2.radius - dist);
            p1.x -= overlap * normalX; p1.y -= overlap * normalY;
            p2.x += overlap * normalX; p2.y += overlap * normalY;
        }

        function handleBoundary(p) {
            if (!boundaryPoints || boundaryPoints.length < 2) return;
            for (let i = 0; i < boundaryPoints.length; i++) {
                const p1 = boundaryPoints[i], p2 = boundaryPoints[(i + 1) % boundaryPoints.length];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                if (dx === 0 && dy === 0) continue;
                const lenSq = dx * dx + dy * dy;
                let t = Math.max(0, Math.min(1, ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / lenSq));
                const cX = p1.x + t * dx, cY = p1.y + t * dy;
                if (Math.hypot(p.x - cX, p.y - cY) < p.radius) {
                    const nX = -dy, nY = dx, nLen = Math.hypot(nX, nY);
                    const dot = p.vx * (nX/nLen) + p.vy * (nY/nLen);
                    p.vx -= (1 + config.bounciness) * dot * (nX/nLen);
                    p.vy -= (1 + config.bounciness) * dot * (nY/nLen);
                }
            }
        }
        
        function drawPlexus() {
            if (config.connectDistance === 0 || particles.length > 300) return;
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dist = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y);
                    if (dist < config.connectDistance) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y); ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${(1 - dist / config.connectDistance) * 0.5})`;
                        ctx.stroke();
                    }
                }
            }
        }

        function animate() {
            ctx.fillStyle = `rgba(0, 0, 0, ${config.trailAmount})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (config.boundaryEnabled && boundaryPoints.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(boundaryPoints[0].x, boundaryPoints[0].y);
                for (let i = 1; i < boundaryPoints.length; i++) ctx.lineTo(boundaryPoints[i].x, boundaryPoints[i].y);
                ctx.closePath(); ctx.stroke();
            }
            if (particles.length < config.maxParticles) {
                for (let i = 0; i < config.spawnRate; i++) particles.push(new Particle(center.x, center.y));
            }
            if (config.enableCollisions) handleParticleCollisions();
            drawPlexus();
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                if (config.boundaryEnabled) handleBoundary(p);
                p.draw();
                if (!config.boundaryEnabled && (p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200)) {
                    particles.splice(i, 1);
                }
            }
            ctx.shadowBlur = 0;
            document.getElementById('particle-count-display').textContent = particles.length;
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // --- 6. UI & EVENT LISTENERS ---
        const modal = document.getElementById('modal-backdrop');
        const openMenuBtn = document.getElementById('open-menu-button');
        const closeMenuBtn = document.getElementById('close-menu-button');
        const resetBtn = document.getElementById('reset-button');
        const playPauseBtn = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const warningModal = document.getElementById('warning-modal');
        const warningInput = document.getElementById('warning-input');
        const warningAgreeBtn = document.getElementById('warning-agree-button');
        const uiContainer = document.getElementById('ui-container');

        function startApplication() {
            warningModal.classList.remove('visible');
            uiContainer.style.visibility = 'visible';
            generateBoundaryPoints(shapeSelect.value);
            isPaused = false; // Unpause
            animate();
        }

        warningAgreeBtn.addEventListener('click', () => {
            if (warningInput.value.trim().toLowerCase() === 'i agree') {
                startApplication();
            }
        });
        warningInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                warningAgreeBtn.click();
            }
        });
        
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(animationFrameId);
                playPauseBtn.title = 'Play Animation';
                pauseIcon.style.display = 'none';
                playIcon.style.display = 'block';
            } else {
                playPauseBtn.title = 'Pause Animation';
                pauseIcon.style.display = 'block';
                playIcon.style.display = 'none';
                animate();
            }
        }

        openMenuBtn.addEventListener('click', () => modal.classList.add('visible'));
        closeMenuBtn.addEventListener('click', () => modal.classList.remove('visible'));
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('visible'); });
        resetBtn.addEventListener('click', () => {
            particles = [new Particle(center.x, center.y)];
            if (isPaused) togglePause();
        });
        playPauseBtn.addEventListener('click', togglePause);

        const shapeSelect = document.getElementById('shape-select');
        Object.keys(SHAPES).forEach(name => shapeSelect.add(new Option(name, name)));
        shapeSelect.value = 'Circle';
        shapeSelect.addEventListener('change', (e) => { generateBoundaryPoints(e.target.value); particles = []; });

        const paletteSelect = document.getElementById('color-palette-select');
        Object.keys(PALETTES).forEach(name => paletteSelect.add(new Option(name, name)));
        paletteSelect.value = 'Neon';
        paletteSelect.addEventListener('change', (e) => { config.activePalette = PALETTES[e.target.value]; particles = []; });

        const controls = [
            { id: 'max-particles-input', configKey: 'maxParticles', isInt: true },
            { id: 'bounciness-slider', configKey: 'bounciness', isInt: false, transform: v => v / 100 },
            { id: 'particle-size-slider', configKey: 'particleSize', isInt: true },
            { id: 'speed-slider', configKey: 'particleSpeed', isInt: true },
            { id: 'spawn-rate-slider', configKey: 'spawnRate', isInt: true },
            { id: 'connect-dist-slider', configKey: 'connectDistance', isInt: true },
            { id: 'gravity-slider', configKey: 'mouseGravity', isInt: true },
            { id: 'trail-slider', configKey: 'trailAmount', isInt: false, transform: v => (100 - v) / 100 },
            { id: 'boundary-checkbox', configKey: 'boundaryEnabled', isCheckbox: true },
            { id: 'collisions-checkbox', configKey: 'enableCollisions', isCheckbox: true },
        ];

        controls.forEach(control => {
            const el = document.getElementById(control.id);
            const valueDisplay = document.getElementById(control.id.replace(/-input|-slider|-select/, '') + '-value');
            el.addEventListener('input', e => {
                const value = control.isCheckbox ? e.target.checked : (control.isInt ? parseInt(e.target.value) : parseFloat(e.target.value));
                config[control.configKey] = control.transform ? control.transform(value) : value;
                if (valueDisplay) {
                    let displayValue = control.isCheckbox ? '' : e.target.value;
                    if(control.id === 'trail-slider' || control.id === 'bounciness-slider') displayValue += '%';
                    valueDisplay.textContent = displayValue;
                }
            });
        });

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', () => {
            if (!isPaused) cancelAnimationFrame(animationFrameId);
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            center = { x: canvas.width / 2, y: canvas.height / 2 };
            generateBoundaryPoints(shapeSelect.value);
            particles = [];
            if (!isPaused) animate();
        });

        // --- 7. STARTUP ---
        // The animation does not start automatically. It waits for user agreement.
    </script>
</body>
</html>
